<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wirepine Lab</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header class="hero">
    <div class="hero-bg"></div>
    <nav class="nav">
      <img src="Wirepine Lab Transparent v1.png" alt="Wirepine" class="nav-logo">
      <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">Dark</button>
    </nav>
    <div class="hero-content">
      <h1 class="hero-title"><span class="wire">Wire</span>pine Lab</h1>
      <p class="hero-subtitle">An AI-native experimental studio</p>
    </div>
  </header>

  <main>
    <section class="manifesto">
      <div class="manifesto-content">
        <h2>Imagine</h2>
        <p><span class="drop-cap">W</span>irepine Lab channels the energy of the early web — when it felt like the internet connected us, information flowed freely, and we weren't buried under feeds and ads. A Golden Age, when it seemed like everything was possible.</p>
        <p>AI is a big wave. Is it a chance to refresh what's gotten tedious? Cynics and AGI believers are everywhere, and the AI-perbole is deafening.</p>
        <p>This is a place to experiment, learn, and draw conclusions from capability — showcasing what's real, and what's hype.</p>
        <p class="manifesto-tagline">Experiments · Systems · AI · Design</p>
      </div>
    </section>

    <section class="experiments">
      <h2>Experiments</h2>
      <div class="experiments-grid">
        <article class="experiment-card">
          <img src="icon library/semantic-drift.svg" alt="" class="experiment-icon">
          <h3>Semantic Drift</h3>
          <p>Exploring how meaning shifts when AI interprets human language across contexts.</p>
        </article>
        <article class="experiment-card">
          <img src="icon library/pattern-emergence.svg" alt="" class="experiment-icon">
          <h3>Pattern Emergence</h3>
          <p>Visualizing the latent structures hidden within generative model outputs.</p>
        </article>
        <article class="experiment-card">
          <img src="icon library/interface-zero.svg" alt="" class="experiment-icon">
          <h3>Interface Zero</h3>
          <p>Designing interactions that disappear—where the tool becomes invisible.</p>
        </article>
        <article class="experiment-card">
          <img src="icon library/synthetic-memory.svg" alt="" class="experiment-icon">
          <h3>Synthetic Memory</h3>
          <p>Building systems that remember differently than we do.</p>
        </article>
        <article class="experiment-card">
          <img src="icon library/constraint-gardens.svg" alt="" class="experiment-icon">
          <h3>Constraint Gardens</h3>
          <p>Growing creativity within deliberate limitations and structured chaos.</p>
        </article>
        <article class="experiment-card">
          <img src="icon library/echo-protocol.svg" alt="" class="experiment-icon">
          <h3>Echo Protocol</h3>
          <p>Feedback loops between human intention and machine interpretation.</p>
        </article>
      </div>
    </section>

    <section class="artifact">
      <h2>Featured Artifact</h2>
      <figure class="artifact-figure">
        <img src="Featured Artifact section hero.png" alt="Topology of Thought - a generative study on the shape of reasoning" class="artifact-image">
        <figcaption>
          <strong>Topology of Thought</strong>
          <span>A generative study on the shape of reasoning—mapping how ideas connect, diverge, and reconverge through iterative AI collaboration.</span>
        </figcaption>
      </figure>
    </section>

    <section class="newsletter" id="newsletter-section">
      <h2>From the Newsletter</h2>
      <div class="newsletter-grid" id="newsletter-feed">
        <div class="skeleton-card"><div class="skeleton-image"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
        <div class="skeleton-card"><div class="skeleton-image"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
        <div class="skeleton-card"><div class="skeleton-image"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
        <div class="skeleton-card"><div class="skeleton-image"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
      </div>
      <a href="https://newsletter.wirepine.com" class="newsletter-cta">Subscribe to TechTales</a>
    </section>
  </main>

  <footer class="footer">
    <div class="footer-content">
      <div class="footer-links">
        <a href="https://wirepine.com">wirepine.com</a>
        <a href="https://newsletter.wirepine.com">newsletter</a>
        <a href="#" id="terminal-trigger" class="terminal-link">view in 1980</a>
      </div>
      <p class="footer-copyright">&copy; 2025 Wirepine Lab. All rights reserved.</p>
    </div>
  </footer>

  <!-- Terminal Mode Overlay -->
  <div id="terminal-mode" class="terminal-overlay" hidden>
    <div class="terminal-screen">
      <div class="terminal-header">
        <span>WIREPINE TERMINAL v1.0</span>
        <button id="terminal-close" class="terminal-btn">[X] EXIT</button>
      </div>
      <div class="terminal-content" id="terminal-content">
        <pre class="ascii-art">
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   █   █ █ █▀▄ █▀▀ █▀█ █ █▄ █ █▀▀   █   █▀█ █▄▄                │
│   ▀▄▀▄▀ █ █▀▄ ██▄ █▀▀ █ █ ▀█ ██▄   █▄▄ █▀█ █▄█                │
│                                                                 │
│            An AI-native experimental studio                     │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   MANIFESTO                                                     │
│   ─────────                                                     │
│   We build at the intersection of artificial intelligence       │
│   and human intent. Where WordPress offered templates,          │
│   we offer transformation.                                      │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   EXPERIMENTS                                                   │
│   ───────────                                                   │
│   [■] Semantic Drift      [■] Pattern Emergence                 │
│   [■] Interface Zero      [■] Synthetic Memory                  │
│   [■] Constraint Gardens  [■] Echo Protocol                     │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   > Press [A] to play ASTEROIDS                                 │
│   > Press [ESC] to return to 2025                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
        </pre>
      </div>
      <canvas id="asteroids-canvas" class="asteroids-game" hidden></canvas>
      <div id="asteroids-ui" class="asteroids-ui" hidden>
        <span>SCORE: <span id="asteroids-score">0</span></span>
        <span>LIVES: <span id="asteroids-lives">3</span></span>
        <button id="asteroids-back" class="terminal-btn">[ESC] BACK</button>
      </div>
    </div>
    <div class="crt-overlay"></div>
  </div>

  <script>
    // Theme toggle (light is default)
    const toggle = document.getElementById('theme-toggle');
    const root = document.documentElement;

    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark') {
      root.setAttribute('data-theme', 'dark');
      toggle.textContent = 'Light';
    }

    toggle.addEventListener('click', () => {
      const isDark = root.getAttribute('data-theme') === 'dark';

      if (isDark) {
        root.removeAttribute('data-theme');
        localStorage.setItem('theme', 'light');
        toggle.textContent = 'Dark';
      } else {
        root.setAttribute('data-theme', 'dark');
        localStorage.setItem('theme', 'dark');
        toggle.textContent = 'Light';
      }
    });

    // Newsletter RSS feed with caching & lazy loading
    const CACHE_KEY = 'wirepine_newsletter';
    const CACHE_TTL = 60 * 60 * 1000; // 1 hour
    const FETCH_TIMEOUT = 5000; // 5 seconds
    let newsletterLoaded = false;

    function renderPosts(posts, feed) {
      feed.innerHTML = posts.map(post => `
        <a href="${post.link}" class="newsletter-card" target="_blank" rel="noopener">
          ${post.image ? `<img src="${post.image}" alt="" class="newsletter-image" loading="lazy">` : ''}
          <div class="newsletter-card-content">
            <time class="newsletter-date">${post.date}</time>
            <h3 class="newsletter-title">${post.title}</h3>
            <p class="newsletter-excerpt">${post.description}</p>
          </div>
        </a>
      `).join('');
    }

    function renderFallback(feed) {
      feed.innerHTML = '<p class="newsletter-error">Loading took too long. <a href="https://newsletter.wirepine.com">Visit the newsletter →</a></p>';
    }

    function getCachedPosts() {
      try {
        const cached = localStorage.getItem(CACHE_KEY);
        if (!cached) return null;
        const { posts, timestamp } = JSON.parse(cached);
        if (Date.now() - timestamp > CACHE_TTL) return null;
        return posts;
      } catch { return null; }
    }

    function cachePosts(posts) {
      try {
        localStorage.setItem(CACHE_KEY, JSON.stringify({ posts, timestamp: Date.now() }));
      } catch {}
    }

    async function fetchPosts() {
      const CORS_PROXY = 'https://api.allorigins.win/raw?url=';
      const RSS_URL = 'https://newsletter.wirepine.com/feed';

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT);

      try {
        const response = await fetch(CORS_PROXY + encodeURIComponent(RSS_URL), { signal: controller.signal });
        clearTimeout(timeoutId);
        const text = await response.text();
        const parser = new DOMParser();
        const xml = parser.parseFromString(text, 'text/xml');
        const items = xml.querySelectorAll('item');

        return Array.from(items).slice(0, 4).map(item => {
          const title = item.querySelector('title')?.textContent || '';
          const link = item.querySelector('link')?.textContent || '';
          const description = item.querySelector('description')?.textContent || '';
          const pubDate = item.querySelector('pubDate')?.textContent || '';
          const enclosure = item.querySelector('enclosure');
          const image = enclosure?.getAttribute('url') || '';
          const date = new Date(pubDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
          return { title, link, description, date, image };
        });
      } catch {
        clearTimeout(timeoutId);
        return null;
      }
    }

    async function loadNewsletter() {
      if (newsletterLoaded) return;
      newsletterLoaded = true;

      const feed = document.getElementById('newsletter-feed');
      const cached = getCachedPosts();

      // Show cached immediately if available
      if (cached) {
        renderPosts(cached, feed);
        // Refresh in background
        fetchPosts().then(posts => {
          if (posts) {
            cachePosts(posts);
            renderPosts(posts, feed);
          }
        });
      } else {
        // No cache - fetch with timeout
        const posts = await fetchPosts();
        if (posts) {
          cachePosts(posts);
          renderPosts(posts, feed);
        } else {
          renderFallback(feed);
        }
      }
    }

    // Lazy load: only fetch when section is visible
    const newsletterSection = document.getElementById('newsletter-section');
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          loadNewsletter();
          observer.disconnect();
        }
      });
    }, { rootMargin: '100px' });
    observer.observe(newsletterSection);

    // ==========================================
    // TERMINAL MODE - 1980 EASTER EGG
    // ==========================================
    const terminalOverlay = document.getElementById('terminal-mode');
    const terminalTrigger = document.getElementById('terminal-trigger');
    const terminalClose = document.getElementById('terminal-close');
    const terminalContent = document.getElementById('terminal-content');
    const asteroidsCanvas = document.getElementById('asteroids-canvas');
    const asteroidsUI = document.getElementById('asteroids-ui');
    const asteroidsBack = document.getElementById('asteroids-back');
    const scoreDisplay = document.getElementById('asteroids-score');
    const livesDisplay = document.getElementById('asteroids-lives');

    let asteroidsGame = null;

    terminalTrigger.addEventListener('click', (e) => {
      e.preventDefault();
      terminalOverlay.hidden = false;
      document.body.style.overflow = 'hidden';
    });

    terminalClose.addEventListener('click', () => {
      closeTerminal();
    });

    function closeTerminal() {
      terminalOverlay.hidden = true;
      document.body.style.overflow = '';
      if (asteroidsGame) {
        asteroidsGame.stop();
        asteroidsGame = null;
      }
      showTerminalContent();
    }

    function showTerminalContent() {
      terminalContent.hidden = false;
      asteroidsCanvas.hidden = true;
      asteroidsUI.hidden = true;
    }

    function showAsteroids() {
      terminalContent.hidden = true;
      asteroidsCanvas.hidden = false;
      asteroidsUI.hidden = false;
      startAsteroids();
    }

    asteroidsBack.addEventListener('click', () => {
      if (asteroidsGame) {
        asteroidsGame.stop();
        asteroidsGame = null;
      }
      showTerminalContent();
    });

    document.addEventListener('keydown', (e) => {
      if (terminalOverlay.hidden) return;

      if (e.key === 'Escape') {
        if (!asteroidsCanvas.hidden) {
          if (asteroidsGame) {
            asteroidsGame.stop();
            asteroidsGame = null;
          }
          showTerminalContent();
        } else {
          closeTerminal();
        }
      }

      if ((e.key === 'a' || e.key === 'A') && !terminalContent.hidden) {
        showAsteroids();
      }
    });

    // ==========================================
    // ASTEROIDS GAME
    // ==========================================

    // Sound effects using Web Audio API
    let audioCtx = null;

    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioCtx;
    }

    function playPew() {
      const ctx = initAudio();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();

      osc.connect(gain);
      gain.connect(ctx.destination);

      osc.type = 'square';
      osc.frequency.setValueAtTime(600, ctx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.1);

      gain.gain.setValueAtTime(0.15, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);

      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.1);
    }

    function playThrust() {
      const ctx = initAudio();
      const bufferSize = ctx.sampleRate * 0.05;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * 0.3;
      }

      const noise = ctx.createBufferSource();
      const gain = ctx.createGain();
      const filter = ctx.createBiquadFilter();

      noise.buffer = buffer;
      filter.type = 'lowpass';
      filter.frequency.value = 200;

      noise.connect(filter);
      filter.connect(gain);
      gain.connect(ctx.destination);

      gain.gain.setValueAtTime(0.1, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05);

      noise.start(ctx.currentTime);
    }

    function playBoom() {
      const ctx = initAudio();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();

      osc.connect(gain);
      gain.connect(ctx.destination);

      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(100, ctx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(30, ctx.currentTime + 0.3);

      gain.gain.setValueAtTime(0.2, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);

      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.3);
    }

    function playShipExplosion() {
      const ctx = initAudio();

      // Layer 1: Deep rumble
      const osc1 = ctx.createOscillator();
      const gain1 = ctx.createGain();
      osc1.connect(gain1);
      gain1.connect(ctx.destination);
      osc1.type = 'sawtooth';
      osc1.frequency.setValueAtTime(80, ctx.currentTime);
      osc1.frequency.exponentialRampToValueAtTime(20, ctx.currentTime + 0.6);
      gain1.gain.setValueAtTime(0.3, ctx.currentTime);
      gain1.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.6);
      osc1.start(ctx.currentTime);
      osc1.stop(ctx.currentTime + 0.6);

      // Layer 2: Mid crunch
      const osc2 = ctx.createOscillator();
      const gain2 = ctx.createGain();
      osc2.connect(gain2);
      gain2.connect(ctx.destination);
      osc2.type = 'square';
      osc2.frequency.setValueAtTime(200, ctx.currentTime);
      osc2.frequency.exponentialRampToValueAtTime(40, ctx.currentTime + 0.4);
      gain2.gain.setValueAtTime(0.2, ctx.currentTime);
      gain2.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
      osc2.start(ctx.currentTime);
      osc2.stop(ctx.currentTime + 0.4);

      // Layer 3: Noise burst
      const bufferSize = ctx.sampleRate * 0.5;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1);
      }
      const noise = ctx.createBufferSource();
      const noiseGain = ctx.createGain();
      const filter = ctx.createBiquadFilter();
      noise.buffer = buffer;
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(1000, ctx.currentTime);
      filter.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.5);
      noise.connect(filter);
      filter.connect(noiseGain);
      noiseGain.connect(ctx.destination);
      noiseGain.gain.setValueAtTime(0.25, ctx.currentTime);
      noiseGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
      noise.start(ctx.currentTime);
    }

    function startAsteroids() {
      const canvas = asteroidsCanvas;
      const ctx = canvas.getContext('2d');

      // Set canvas size
      const container = canvas.parentElement;
      canvas.width = container.clientWidth - 4;
      canvas.height = container.clientHeight - 100;

      let animationId;
      let gameRunning = true;
      let score = 0;
      let lives = 3;

      // Ship
      const ship = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 15,
        angle: -Math.PI / 2,
        rotation: 0,
        thrusting: false,
        thrust: { x: 0, y: 0 },
        bullets: []
      };

      // Asteroids
      let asteroids = [];
      const ASTEROID_COUNT = 5;

      function createAsteroid(x, y, radius) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 2;
        return {
          x: x || Math.random() * canvas.width,
          y: y || Math.random() * canvas.height,
          radius: radius || 40 + Math.random() * 20,
          angle: angle,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          vertices: Math.floor(8 + Math.random() * 6),
          offsets: Array.from({ length: 14 }, () => 0.7 + Math.random() * 0.4)
        };
      }

      function initAsteroids() {
        asteroids = [];
        for (let i = 0; i < ASTEROID_COUNT; i++) {
          let a = createAsteroid();
          // Make sure asteroid doesn't spawn on ship
          while (Math.hypot(a.x - ship.x, a.y - ship.y) < 100) {
            a = createAsteroid();
          }
          asteroids.push(a);
        }
      }

      // Input
      const keys = {};
      function handleKeyDown(e) {
        keys[e.key] = true;
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
          e.preventDefault();
        }
      }
      function handleKeyUp(e) {
        keys[e.key] = false;
      }
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keyup', handleKeyUp);

      function shoot() {
        ship.bullets.push({
          x: ship.x + Math.cos(ship.angle) * ship.radius,
          y: ship.y + Math.sin(ship.angle) * ship.radius,
          vx: Math.cos(ship.angle) * 8,
          vy: Math.sin(ship.angle) * 8,
          life: 60
        });
        playPew();
      }

      let canShoot = true;
      let canThrust = true;
      let invulnerable = false;

      function update() {
        // Rotation
        if (keys['ArrowLeft']) ship.angle -= 0.08;
        if (keys['ArrowRight']) ship.angle += 0.08;

        // Thrust
        if (keys['ArrowUp']) {
          ship.thrust.x += Math.cos(ship.angle) * 0.15;
          ship.thrust.y += Math.sin(ship.angle) * 0.15;
          ship.thrusting = true;
          if (canThrust) {
            playThrust();
            canThrust = false;
            setTimeout(() => canThrust = true, 80);
          }
        } else {
          ship.thrusting = false;
        }

        // Shoot
        if (keys[' '] && canShoot) {
          shoot();
          canShoot = false;
          setTimeout(() => canShoot = true, 200);
        }

        // Apply thrust with friction
        ship.x += ship.thrust.x;
        ship.y += ship.thrust.y;
        ship.thrust.x *= 0.99;
        ship.thrust.y *= 0.99;

        // Wrap ship
        if (ship.x < 0) ship.x = canvas.width;
        if (ship.x > canvas.width) ship.x = 0;
        if (ship.y < 0) ship.y = canvas.height;
        if (ship.y > canvas.height) ship.y = 0;

        // Update bullets
        ship.bullets = ship.bullets.filter(b => {
          b.x += b.vx;
          b.y += b.vy;
          b.life--;
          // Wrap bullets
          if (b.x < 0) b.x = canvas.width;
          if (b.x > canvas.width) b.x = 0;
          if (b.y < 0) b.y = canvas.height;
          if (b.y > canvas.height) b.y = 0;
          return b.life > 0;
        });

        // Update asteroids
        asteroids.forEach(a => {
          a.x += a.vx;
          a.y += a.vy;
          // Wrap
          if (a.x < -a.radius) a.x = canvas.width + a.radius;
          if (a.x > canvas.width + a.radius) a.x = -a.radius;
          if (a.y < -a.radius) a.y = canvas.height + a.radius;
          if (a.y > canvas.height + a.radius) a.y = -a.radius;
        });

        // Collision: bullets vs asteroids
        ship.bullets.forEach((b, bi) => {
          asteroids.forEach((a, ai) => {
            if (Math.hypot(b.x - a.x, b.y - a.y) < a.radius) {
              // Hit!
              ship.bullets.splice(bi, 1);
              score += Math.floor(100 / a.radius * 10);
              scoreDisplay.textContent = score;
              playBoom();

              // Split asteroid
              if (a.radius > 20) {
                asteroids.push(createAsteroid(a.x, a.y, a.radius / 2));
                asteroids.push(createAsteroid(a.x, a.y, a.radius / 2));
              }
              asteroids.splice(ai, 1);
            }
          });
        });

        // Collision: ship vs asteroids
        if (!invulnerable) {
          for (let i = 0; i < asteroids.length; i++) {
            const a = asteroids[i];
            if (Math.hypot(ship.x - a.x, ship.y - a.y) < ship.radius + a.radius - 10) {
              lives--;
              livesDisplay.textContent = lives;
              playShipExplosion();
              // Reset ship with invulnerability
              ship.x = canvas.width / 2;
              ship.y = canvas.height / 2;
              ship.thrust = { x: 0, y: 0 };
              invulnerable = true;
              setTimeout(() => invulnerable = false, 2000);
              if (lives <= 0) {
                gameOver();
              }
              break; // Only one collision per frame
            }
          }
        }

        // Level complete
        if (asteroids.length === 0) {
          initAsteroids();
        }
      }

      function draw() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = '#0f0';
        ctx.lineWidth = 1.5;
        ctx.shadowColor = '#0f0';
        ctx.shadowBlur = 10;

        // Draw ship (blink when invulnerable)
        if (!invulnerable || Math.floor(Date.now() / 100) % 2) {
          ctx.save();
          ctx.translate(ship.x, ship.y);
          ctx.rotate(ship.angle);
          ctx.beginPath();
          ctx.moveTo(ship.radius, 0);
          ctx.lineTo(-ship.radius * 0.7, -ship.radius * 0.6);
          ctx.lineTo(-ship.radius * 0.4, 0);
          ctx.lineTo(-ship.radius * 0.7, ship.radius * 0.6);
          ctx.closePath();
          ctx.stroke();

          // Thrust flame
          if (ship.thrusting) {
            ctx.beginPath();
            ctx.moveTo(-ship.radius * 0.4, 0);
            ctx.lineTo(-ship.radius * 1.2, -ship.radius * 0.2);
            ctx.lineTo(-ship.radius * 1.5, 0);
            ctx.lineTo(-ship.radius * 1.2, ship.radius * 0.2);
            ctx.closePath();
            ctx.stroke();
          }
          ctx.restore();
        }

        // Draw bullets
        ship.bullets.forEach(b => {
          ctx.beginPath();
          ctx.arc(b.x, b.y, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#0f0';
        });

        // Draw asteroids
        asteroids.forEach(a => {
          ctx.beginPath();
          for (let i = 0; i < a.vertices; i++) {
            const angle = (i / a.vertices) * Math.PI * 2;
            const r = a.radius * a.offsets[i];
            const x = a.x + Math.cos(angle) * r;
            const y = a.y + Math.sin(angle) * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.stroke();
        });

        ctx.shadowBlur = 0;
      }

      function gameOver() {
        gameRunning = false;
        ctx.fillStyle = '#0f0';
        ctx.font = '30px "Courier New"';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#0f0';
        ctx.shadowBlur = 20;
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
        ctx.font = '16px "Courier New"';
        ctx.fillText('Score: ' + score, canvas.width / 2, canvas.height / 2 + 40);
        ctx.fillText('Press ESC to return', canvas.width / 2, canvas.height / 2 + 70);
      }

      function gameLoop() {
        if (!gameRunning) return;
        update();
        draw();
        animationId = requestAnimationFrame(gameLoop);
      }

      // Initialize
      score = 0;
      lives = 3;
      scoreDisplay.textContent = score;
      livesDisplay.textContent = lives;
      initAsteroids();
      gameLoop();

      // Return stop function
      asteroidsGame = {
        stop: () => {
          gameRunning = false;
          cancelAnimationFrame(animationId);
          document.removeEventListener('keydown', handleKeyDown);
          document.removeEventListener('keyup', handleKeyUp);
        }
      };
    }
  </script>
</body>
</html>
