<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wirepine Lab</title>
  <link rel="icon" type="image/png" href="Wirepine Lab Transparent v1.png">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header class="hero">
    <div class="hero-bg"></div>
    <nav class="nav">
      <img src="Wirepine Lab Transparent v1.png" alt="Wirepine" class="nav-logo">
      <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">Dark</button>
    </nav>
    <div class="hero-content">
      <h1 class="hero-title"><span class="wire">Wire</span>pine Lab</h1>
      <p class="hero-subtitle">The AI-pocalypse starts here</p>
    </div>
  </header>

  <main>
    <section class="manifesto">
      <div class="manifesto-content">
        <h2>AI-magination</h2>
        <p><span class="drop-cap">W</span>irepine Lab is looking for the energy of the early web — when it felt like the internet connected us, information flowed freely, and we weren't buried under feeds and ads. A Golden Age, when it seemed like everything was possible.</p>
        <p>AI is a big wave. Is it a chance to refresh what's gotten tedious? Cynics on one side, AI-pilled on the other, the AI-perbole can be deafening.</p>
        <p>This place is built on AI to experiment, learn, and make conclusions based on capability — teasing out what's real from the hype.</p>
        <p class="manifesto-tagline">Experiments · Systems · Design</p>
      </div>
    </section>

    <section class="experiments">
      <h2>AI-perbole</h2>
      <div class="experiments-grid">
        <article class="experiment-card">
          <img src="icon library/semantic-drift.svg" alt="" class="experiment-icon">
          <h3>Semantic Drift</h3>
          <p>Exploring how meaning shifts when AI interprets human language across contexts.</p>
        </article>
        <article class="experiment-card">
          <img src="icon library/pattern-emergence.svg" alt="" class="experiment-icon">
          <h3>Pattern Emergence</h3>
          <p>Visualizing the latent structures hidden within generative model outputs.</p>
        </article>
        <article class="experiment-card">
          <img src="icon library/interface-zero.svg" alt="" class="experiment-icon">
          <h3>Interface Zero</h3>
          <p>Designing interactions that disappear—where the tool becomes invisible.</p>
        </article>
        <article class="experiment-card">
          <img src="icon library/synthetic-memory.svg" alt="" class="experiment-icon">
          <h3>Synthetic Memory</h3>
          <p>Building systems that remember differently than we do.</p>
        </article>
        <article class="experiment-card">
          <img src="icon library/constraint-gardens.svg" alt="" class="experiment-icon">
          <h3>Constraint Gardens</h3>
          <p>Growing creativity within deliberate limitations and structured chaos.</p>
        </article>
        <article class="experiment-card">
          <img src="icon library/echo-protocol.svg" alt="" class="experiment-icon">
          <h3>Echo Protocol</h3>
          <p>Feedback loops between human intention and machine interpretation.</p>
        </article>
      </div>
    </section>

    <section class="artifact">
      <h2>AI-steria</h2>
      <figure class="artifact-figure">
        <img src="Featured Artifact section hero.png" alt="How this was Built - Wirepine Lab built with Claude Code" class="artifact-image">
        <figcaption>
          <strong>How this was Built</strong>
          <span>Wirepine Lab was built with Claude Code, end to end. Version one started deliberately simple and took an hour: a basic static site sharpening the new Wirepine brand, designed to complement the main site and the newsletter — not replace them. <br><br> Version two focused on refinement and took a few more hours: tightening the design, clarifying intent, and wiring up deployment so changes flow cleanly from idea to code to a live URL.  <br><br> No CMS. No plugins. No Frameworks. Yes Easter Egg! </span>
        </figcaption>
      </figure>
    </section>

    <section class="newsletter" id="newsletter-section">
      <h2>From the Newsletter</h2>
      <div class="newsletter-grid" id="newsletter-feed">
        <div class="skeleton-card"><div class="skeleton-image"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
        <div class="skeleton-card"><div class="skeleton-image"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
        <div class="skeleton-card"><div class="skeleton-image"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
        <div class="skeleton-card"><div class="skeleton-image"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>
      </div>
      <a href="https://newsletter.wirepine.com" class="newsletter-cta">Subscribe to TechTales</a>
    </section>
  </main>

  <footer class="footer">
    <div class="footer-content">
      <div class="footer-links">
        <a href="https://wirepine.com">wirepine.com</a>
        <a href="https://newsletter.wirepine.com">newsletter</a>
        <a href="#" id="terminal-trigger" class="terminal-link">view in 1999</a>
      </div>
      <p class="footer-copyright">&copy; 2026 Wirepine. All rights reserved.</p>
    </div>
  </footer>

  <!-- Matrix Rain Transition -->
  <canvas id="matrix-canvas" class="matrix-canvas" hidden></canvas>

  <!-- Terminal Mode Overlay -->
  <div id="terminal-mode" class="terminal-overlay" hidden>
    <div class="terminal-screen">
      <div class="terminal-header">
        <span>WIREPINE TERMINAL v1.0</span>
        <button id="terminal-close" class="terminal-btn">[X] EXIT</button>
      </div>
      <div class="terminal-content" id="terminal-content">
        <pre class="ascii-art">
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   █   █ █ █▀▄ █▀▀ █▀█ █ █▄ █ █▀▀   █   █▀█ █▄▄                  │
│   ▀▄▀▄▀ █ █▀▄ ██▄ █▀▀ █ █ ▀█ ██▄   █▄▄ █▀█ █▄█                  │
│                                                                 │
│           The AI-pocalypse starts here                          │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   AI-MAGINATION                                                 │
│   ───────                                                       │
│   Wirepine Lab is looking for the energy of the early web—when   │
│   it felt like the internet connected us, information flowed    │
│   freely, and we weren't buried under feeds and ads. A Golden   │
│   Age, when it seemed like everything was possible.             │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   AI-PERBOLE                                                    │
│   ───────────                                                   │
│   [■] Semantic Drift      [■] Pattern Emergence                 │
│   [■] Interface Zero      [■] Synthetic Memory                  │
│   [■] Constraint Gardens  [■] Echo Protocol                     │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   <span class="desktop-only">> Press [A] to play ASTEROIDS                                 </span><span class="mobile-only">> View on desktop to play ASTEROIDS                           </span>│
│   > Press [ESC] to return to 2026                               │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│   PUNKS: <span id="view-count">...</span>                                                 │
└─────────────────────────────────────────────────────────────────┘
        </pre>
      </div>
      <canvas id="asteroids-canvas" class="asteroids-game" hidden></canvas>
      <div id="asteroids-ui" class="asteroids-ui" hidden>
        <span>SCORE: <span id="asteroids-score">0</span></span>
        <span>LIVES: <span id="asteroids-lives">3</span></span>
        <button id="asteroids-back" class="terminal-btn">[ESC] BACK</button>
      </div>
    </div>
    <div class="crt-overlay"></div>
  </div>

  <script>
    // Theme toggle (dark is default)
    const toggle = document.getElementById('theme-toggle');
    const root = document.documentElement;

    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'light') {
      root.removeAttribute('data-theme');
      toggle.textContent = 'Dark';
    } else {
      root.setAttribute('data-theme', 'dark');
      toggle.textContent = 'Light';
    }

    toggle.addEventListener('click', () => {
      const isDark = root.getAttribute('data-theme') === 'dark';

      if (isDark) {
        root.removeAttribute('data-theme');
        localStorage.setItem('theme', 'light');
        toggle.textContent = 'Dark';
      } else {
        root.setAttribute('data-theme', 'dark');
        localStorage.setItem('theme', 'dark');
        toggle.textContent = 'Light';
      }
    });

    // Page view counter (displayed in terminal easter egg)
    fetch('https://abacus.jasoncameron.dev/hit/wirepine-lab/pageviews')
      .then(r => r.json())
      .then(data => {
        document.getElementById('view-count').textContent = data.value.toLocaleString();
      })
      .catch(() => {});

    // Newsletter RSS feed with caching & lazy loading
    const CACHE_KEY = 'wirepine_newsletter';
    const CACHE_TTL = 60 * 60 * 1000; // 1 hour
    const FETCH_TIMEOUT = 8000; // 8 seconds
    let newsletterLoaded = false;

    function renderPosts(posts, feed) {
      feed.innerHTML = posts.map(post => `
        <a href="${post.link}" class="newsletter-card" target="_blank" rel="noopener">
          ${post.image ? `<img src="${post.image}" alt="" class="newsletter-image" loading="lazy">` : ''}
          <div class="newsletter-card-content">
            <time class="newsletter-date">${post.date}</time>
            <h3 class="newsletter-title">${post.title}</h3>
            <p class="newsletter-excerpt">${post.description}</p>
          </div>
        </a>
      `).join('');
    }

    function renderFallback(feed) {
      feed.innerHTML = '<p class="newsletter-error">Loading took too long. <a href="https://newsletter.wirepine.com">Visit the newsletter →</a></p>';
    }

    function getCachedPosts() {
      try {
        const cached = localStorage.getItem(CACHE_KEY);
        if (!cached) return null;
        const { posts, timestamp } = JSON.parse(cached);
        if (Date.now() - timestamp > CACHE_TTL) return null;
        return posts;
      } catch { return null; }
    }

    function cachePosts(posts) {
      try {
        localStorage.setItem(CACHE_KEY, JSON.stringify({ posts, timestamp: Date.now() }));
      } catch {}
    }

    async function fetchPosts() {
      const CORS_PROXY = 'https://corsproxy.io/?';
      const RSS_URL = 'https://newsletter.wirepine.com/feed';

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT);

      try {
        const response = await fetch(CORS_PROXY + RSS_URL, { signal: controller.signal });
        clearTimeout(timeoutId);
        const text = await response.text();
        const parser = new DOMParser();
        const xml = parser.parseFromString(text, 'text/xml');
        const items = xml.querySelectorAll('item');

        return Array.from(items).slice(0, 4).map(item => {
          const title = item.querySelector('title')?.textContent || '';
          const link = item.querySelector('link')?.textContent || '';
          const description = item.querySelector('description')?.textContent || '';
          const pubDate = item.querySelector('pubDate')?.textContent || '';
          const enclosure = item.querySelector('enclosure');
          const image = enclosure?.getAttribute('url') || '';
          const date = new Date(pubDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
          return { title, link, description, date, image };
        });
      } catch {
        clearTimeout(timeoutId);
        return null;
      }
    }

    async function loadNewsletter() {
      if (newsletterLoaded) return;
      newsletterLoaded = true;

      const feed = document.getElementById('newsletter-feed');
      const cached = getCachedPosts();

      // Show cached immediately if available
      if (cached) {
        renderPosts(cached, feed);
        // Refresh in background
        fetchPosts().then(posts => {
          if (posts) {
            cachePosts(posts);
            renderPosts(posts, feed);
          }
        });
      } else {
        // No cache - fetch with timeout
        const posts = await fetchPosts();
        if (posts) {
          cachePosts(posts);
          renderPosts(posts, feed);
        } else {
          renderFallback(feed);
        }
      }
    }

    // Lazy load: only fetch when section is visible
    const newsletterSection = document.getElementById('newsletter-section');
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          loadNewsletter();
          observer.disconnect();
        }
      });
    }, { rootMargin: '100px' });
    observer.observe(newsletterSection);

    // ==========================================
    // TERMINAL MODE - 1980 EASTER EGG
    // ==========================================
    const terminalOverlay = document.getElementById('terminal-mode');
    const terminalTrigger = document.getElementById('terminal-trigger');
    const terminalClose = document.getElementById('terminal-close');
    const terminalContent = document.getElementById('terminal-content');
    const asteroidsCanvas = document.getElementById('asteroids-canvas');
    const asteroidsUI = document.getElementById('asteroids-ui');
    const asteroidsBack = document.getElementById('asteroids-back');
    const scoreDisplay = document.getElementById('asteroids-score');
    const livesDisplay = document.getElementById('asteroids-lives');
    const matrixCanvas = document.getElementById('matrix-canvas');

    let asteroidsGame = null;

    // ==========================================
    // MATRIX RAIN TRANSITION
    // ==========================================
    function playMatrixTransition(callback) {
      const canvas = matrixCanvas;
      const ctx = canvas.getContext('2d');

      // Set canvas size
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      canvas.hidden = false;
      document.body.style.overflow = 'hidden';

      const fontSize = 16;
      const columns = Math.floor(canvas.width / fontSize);

      // Array of drops - one per column, with individual speeds
      const drops = [];
      const speeds = [];
      const active = []; // Whether this column is active
      for (let i = 0; i < columns; i++) {
        drops[i] = Math.random() * -50;
        speeds[i] = 0.5 + Math.random() * 0.5; // Base speed
        active[i] = Math.random() > 0.7; // Start with ~30% columns active
      }

      const chars = '01';
      let frameCount = 0;
      const duration = 200; // ~3 seconds at 60fps
      let animationId;

      function draw() {
        // Progress from 0 to 1
        const progress = frameCount / duration;

        // Speed multiplier increases over time (1x to 3x)
        const speedMultiplier = 1 + progress * 2;

        // Density increases over time - activate more columns
        const activationChance = 0.02 + progress * 0.08;

        // Fade trail - shorter trail as speed increases
        const fadeAmount = 0.03 + progress * 0.04;
        ctx.fillStyle = `rgba(0, 0, 0, ${fadeAmount})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.font = fontSize + 'px monospace';
        ctx.shadowColor = '#0f0';
        ctx.shadowBlur = 8 + progress * 8;

        for (let i = 0; i < drops.length; i++) {
          // Activate inactive columns over time
          if (!active[i] && Math.random() < activationChance) {
            active[i] = true;
            drops[i] = 0;
          }

          if (!active[i]) continue;

          // Random character
          const char = chars[Math.floor(Math.random() * chars.length)];

          // Draw character
          const x = i * fontSize;
          const y = drops[i] * fontSize;

          // Brighter leading character
          if (Math.random() > 0.5) {
            ctx.fillStyle = '#fff';
          } else {
            ctx.fillStyle = '#0f0';
          }

          ctx.fillText(char, x, y);

          // Move drop down with increasing speed
          drops[i] += speeds[i] * speedMultiplier;

          // Reset drop to top - more likely to reset as time goes on (more density)
          const resetChance = 0.975 - progress * 0.02;
          if (drops[i] * fontSize > canvas.height && Math.random() > resetChance) {
            drops[i] = 0;
            speeds[i] = 0.5 + Math.random() * 0.5 + progress; // Faster respawns over time
          }
        }

        ctx.shadowBlur = 0;
        frameCount++;

        if (frameCount < duration) {
          animationId = requestAnimationFrame(draw);
        } else {
          // Fade out and transition
          fadeOut();
        }
      }

      function fadeOut() {
        let opacity = 1;
        function fade() {
          opacity -= 0.05;
          ctx.fillStyle = `rgba(0, 0, 0, ${0.1})`;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          if (opacity > 0) {
            requestAnimationFrame(fade);
          } else {
            canvas.hidden = true;
            callback();
          }
        }
        fade();
      }

      draw();
    }

    terminalTrigger.addEventListener('click', (e) => {
      e.preventDefault();
      playMatrixTransition(() => {
        terminalOverlay.hidden = false;
      });
    });

    terminalClose.addEventListener('click', () => {
      closeTerminal();
    });

    function closeTerminal() {
      terminalOverlay.hidden = true;
      document.body.style.overflow = '';
      if (asteroidsGame) {
        asteroidsGame.stop();
        asteroidsGame = null;
      }
      showTerminalContent();
    }

    function showTerminalContent() {
      terminalContent.hidden = false;
      asteroidsCanvas.hidden = true;
      asteroidsUI.hidden = true;
    }

    function showAsteroids() {
      terminalContent.hidden = true;
      asteroidsCanvas.hidden = false;
      asteroidsUI.hidden = false;
      startAsteroids();
    }

    asteroidsBack.addEventListener('click', () => {
      if (asteroidsGame) {
        asteroidsGame.stop();
        asteroidsGame = null;
      }
      showTerminalContent();
    });

    document.addEventListener('keydown', (e) => {
      if (terminalOverlay.hidden) return;

      if (e.key === 'Escape') {
        if (!asteroidsCanvas.hidden) {
          if (asteroidsGame) {
            asteroidsGame.stop();
            asteroidsGame = null;
          }
          showTerminalContent();
        } else {
          closeTerminal();
        }
      }

      if ((e.key === 'a' || e.key === 'A') && !terminalContent.hidden && window.innerWidth > 768) {
        showAsteroids();
      }
    });

    // ==========================================
    // ASTEROIDS GAME
    // ==========================================

    // Sound effects using Web Audio API
    let audioCtx = null;

    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioCtx;
    }

    function playPew() {
      const ctx = initAudio();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();

      osc.connect(gain);
      gain.connect(ctx.destination);

      osc.type = 'square';
      osc.frequency.setValueAtTime(600, ctx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.1);

      gain.gain.setValueAtTime(0.15, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);

      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.1);
    }

    function playThrust() {
      const ctx = initAudio();
      const bufferSize = ctx.sampleRate * 0.05;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * 0.3;
      }

      const noise = ctx.createBufferSource();
      const gain = ctx.createGain();
      const filter = ctx.createBiquadFilter();

      noise.buffer = buffer;
      filter.type = 'lowpass';
      filter.frequency.value = 200;

      noise.connect(filter);
      filter.connect(gain);
      gain.connect(ctx.destination);

      gain.gain.setValueAtTime(0.1, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05);

      noise.start(ctx.currentTime);
    }

    function playBoom() {
      const ctx = initAudio();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();

      osc.connect(gain);
      gain.connect(ctx.destination);

      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(100, ctx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(30, ctx.currentTime + 0.3);

      gain.gain.setValueAtTime(0.2, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);

      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.3);
    }

    function playShipExplosion() {
      const ctx = initAudio();

      // Layer 1: Deep rumble
      const osc1 = ctx.createOscillator();
      const gain1 = ctx.createGain();
      osc1.connect(gain1);
      gain1.connect(ctx.destination);
      osc1.type = 'sawtooth';
      osc1.frequency.setValueAtTime(80, ctx.currentTime);
      osc1.frequency.exponentialRampToValueAtTime(20, ctx.currentTime + 0.6);
      gain1.gain.setValueAtTime(0.3, ctx.currentTime);
      gain1.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.6);
      osc1.start(ctx.currentTime);
      osc1.stop(ctx.currentTime + 0.6);

      // Layer 2: Mid crunch
      const osc2 = ctx.createOscillator();
      const gain2 = ctx.createGain();
      osc2.connect(gain2);
      gain2.connect(ctx.destination);
      osc2.type = 'square';
      osc2.frequency.setValueAtTime(200, ctx.currentTime);
      osc2.frequency.exponentialRampToValueAtTime(40, ctx.currentTime + 0.4);
      gain2.gain.setValueAtTime(0.2, ctx.currentTime);
      gain2.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
      osc2.start(ctx.currentTime);
      osc2.stop(ctx.currentTime + 0.4);

      // Layer 3: Noise burst
      const bufferSize = ctx.sampleRate * 0.5;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1);
      }
      const noise = ctx.createBufferSource();
      const noiseGain = ctx.createGain();
      const filter = ctx.createBiquadFilter();
      noise.buffer = buffer;
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(1000, ctx.currentTime);
      filter.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.5);
      noise.connect(filter);
      filter.connect(noiseGain);
      noiseGain.connect(ctx.destination);
      noiseGain.gain.setValueAtTime(0.25, ctx.currentTime);
      noiseGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
      noise.start(ctx.currentTime);
    }

    function startAsteroids() {
      const canvas = asteroidsCanvas;
      const ctx = canvas.getContext('2d');

      // Set canvas size
      const container = canvas.parentElement;
      canvas.width = container.clientWidth - 4;
      canvas.height = container.clientHeight - 100;

      let animationId;
      let gameRunning = true;
      let score = 0;
      let lives = 3;

      // Ship
      const ship = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 15,
        angle: -Math.PI / 2,
        rotation: 0,
        thrusting: false,
        thrust: { x: 0, y: 0 },
        bullets: []
      };

      // Asteroids
      let asteroids = [];
      const ASTEROID_COUNT = 5;

      function createAsteroid(x, y, radius) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 2;
        return {
          x: x || Math.random() * canvas.width,
          y: y || Math.random() * canvas.height,
          radius: radius || 40 + Math.random() * 20,
          angle: angle,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          vertices: Math.floor(8 + Math.random() * 6),
          offsets: Array.from({ length: 14 }, () => 0.7 + Math.random() * 0.4)
        };
      }

      function initAsteroids() {
        asteroids = [];
        for (let i = 0; i < ASTEROID_COUNT; i++) {
          let a = createAsteroid();
          // Make sure asteroid doesn't spawn on ship
          while (Math.hypot(a.x - ship.x, a.y - ship.y) < 100) {
            a = createAsteroid();
          }
          asteroids.push(a);
        }
      }

      // Input
      const keys = {};
      function handleKeyDown(e) {
        keys[e.key] = true;
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
          e.preventDefault();
        }
      }
      function handleKeyUp(e) {
        keys[e.key] = false;
      }
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keyup', handleKeyUp);

      function shoot() {
        ship.bullets.push({
          x: ship.x + Math.cos(ship.angle) * ship.radius,
          y: ship.y + Math.sin(ship.angle) * ship.radius,
          vx: Math.cos(ship.angle) * 8,
          vy: Math.sin(ship.angle) * 8,
          life: 60
        });
        playPew();
      }

      let canShoot = true;
      let canThrust = true;
      let invulnerable = false;

      function update() {
        // Rotation
        if (keys['ArrowLeft']) ship.angle -= 0.08;
        if (keys['ArrowRight']) ship.angle += 0.08;

        // Thrust
        if (keys['ArrowUp']) {
          ship.thrust.x += Math.cos(ship.angle) * 0.15;
          ship.thrust.y += Math.sin(ship.angle) * 0.15;
          ship.thrusting = true;
          if (canThrust) {
            playThrust();
            canThrust = false;
            setTimeout(() => canThrust = true, 80);
          }
        } else {
          ship.thrusting = false;
        }

        // Shoot
        if (keys[' '] && canShoot) {
          shoot();
          canShoot = false;
          setTimeout(() => canShoot = true, 200);
        }

        // Apply thrust with friction
        ship.x += ship.thrust.x;
        ship.y += ship.thrust.y;
        ship.thrust.x *= 0.99;
        ship.thrust.y *= 0.99;

        // Wrap ship
        if (ship.x < 0) ship.x = canvas.width;
        if (ship.x > canvas.width) ship.x = 0;
        if (ship.y < 0) ship.y = canvas.height;
        if (ship.y > canvas.height) ship.y = 0;

        // Update bullets
        ship.bullets = ship.bullets.filter(b => {
          b.x += b.vx;
          b.y += b.vy;
          b.life--;
          // Wrap bullets
          if (b.x < 0) b.x = canvas.width;
          if (b.x > canvas.width) b.x = 0;
          if (b.y < 0) b.y = canvas.height;
          if (b.y > canvas.height) b.y = 0;
          return b.life > 0;
        });

        // Update asteroids
        asteroids.forEach(a => {
          a.x += a.vx;
          a.y += a.vy;
          // Wrap
          if (a.x < -a.radius) a.x = canvas.width + a.radius;
          if (a.x > canvas.width + a.radius) a.x = -a.radius;
          if (a.y < -a.radius) a.y = canvas.height + a.radius;
          if (a.y > canvas.height + a.radius) a.y = -a.radius;
        });

        // Collision: bullets vs asteroids
        ship.bullets.forEach((b, bi) => {
          asteroids.forEach((a, ai) => {
            if (Math.hypot(b.x - a.x, b.y - a.y) < a.radius) {
              // Hit!
              ship.bullets.splice(bi, 1);
              score += Math.floor(100 / a.radius * 10);
              scoreDisplay.textContent = score;
              playBoom();

              // Split asteroid
              if (a.radius > 20) {
                asteroids.push(createAsteroid(a.x, a.y, a.radius / 2));
                asteroids.push(createAsteroid(a.x, a.y, a.radius / 2));
              }
              asteroids.splice(ai, 1);
            }
          });
        });

        // Collision: ship vs asteroids
        if (!invulnerable) {
          for (let i = 0; i < asteroids.length; i++) {
            const a = asteroids[i];
            if (Math.hypot(ship.x - a.x, ship.y - a.y) < ship.radius + a.radius - 10) {
              lives--;
              livesDisplay.textContent = lives;
              playShipExplosion();
              // Reset ship with invulnerability
              ship.x = canvas.width / 2;
              ship.y = canvas.height / 2;
              ship.thrust = { x: 0, y: 0 };
              invulnerable = true;
              setTimeout(() => invulnerable = false, 2000);
              if (lives <= 0) {
                gameOver();
              }
              break; // Only one collision per frame
            }
          }
        }

        // Level complete
        if (asteroids.length === 0) {
          initAsteroids();
        }
      }

      function draw() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = '#0f0';
        ctx.lineWidth = 1.5;
        ctx.shadowColor = '#0f0';
        ctx.shadowBlur = 10;

        // Draw ship (blink when invulnerable)
        if (!invulnerable || Math.floor(Date.now() / 100) % 2) {
          ctx.save();
          ctx.translate(ship.x, ship.y);
          ctx.rotate(ship.angle);
          ctx.beginPath();
          ctx.moveTo(ship.radius, 0);
          ctx.lineTo(-ship.radius * 0.7, -ship.radius * 0.6);
          ctx.lineTo(-ship.radius * 0.4, 0);
          ctx.lineTo(-ship.radius * 0.7, ship.radius * 0.6);
          ctx.closePath();
          ctx.stroke();

          // Thrust flame
          if (ship.thrusting) {
            ctx.beginPath();
            ctx.moveTo(-ship.radius * 0.4, 0);
            ctx.lineTo(-ship.radius * 1.2, -ship.radius * 0.2);
            ctx.lineTo(-ship.radius * 1.5, 0);
            ctx.lineTo(-ship.radius * 1.2, ship.radius * 0.2);
            ctx.closePath();
            ctx.stroke();
          }
          ctx.restore();
        }

        // Draw bullets
        ship.bullets.forEach(b => {
          ctx.beginPath();
          ctx.arc(b.x, b.y, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#0f0';
        });

        // Draw asteroids
        asteroids.forEach(a => {
          ctx.beginPath();
          for (let i = 0; i < a.vertices; i++) {
            const angle = (i / a.vertices) * Math.PI * 2;
            const r = a.radius * a.offsets[i];
            const x = a.x + Math.cos(angle) * r;
            const y = a.y + Math.sin(angle) * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.stroke();
        });

        ctx.shadowBlur = 0;
      }

      function gameOver() {
        gameRunning = false;
        ctx.fillStyle = '#0f0';
        ctx.font = '30px "Courier New"';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#0f0';
        ctx.shadowBlur = 20;
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
        ctx.font = '16px "Courier New"';
        ctx.fillText('Score: ' + score, canvas.width / 2, canvas.height / 2 + 40);
        ctx.fillText('Press ESC to return', canvas.width / 2, canvas.height / 2 + 70);
      }

      function gameLoop() {
        if (!gameRunning) return;
        update();
        draw();
        animationId = requestAnimationFrame(gameLoop);
      }

      // Initialize
      score = 0;
      lives = 3;
      scoreDisplay.textContent = score;
      livesDisplay.textContent = lives;
      initAsteroids();
      gameLoop();

      // Return stop function
      asteroidsGame = {
        stop: () => {
          gameRunning = false;
          cancelAnimationFrame(animationId);
          document.removeEventListener('keydown', handleKeyDown);
          document.removeEventListener('keyup', handleKeyUp);
        }
      };
    }
  </script>
</body>
</html>
